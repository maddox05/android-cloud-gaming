#!/bin/bash
# Start all 3 components of android-cloud-gaming

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Load .env file (required)
if [ -f "$SCRIPT_DIR/.env" ]; then
  echo -e "${GREEN}Loading .env file...${NC}"
  set -a
  source "$SCRIPT_DIR/.env"
  set +a
else
  echo -e "${RED}Error: .env file not found${NC}"
  echo -e "Copy .env.example to .env and configure it:"
  echo -e "  cp .env.example .env"
  exit 1
fi

# Validate required env vars
if [ -z "$SIGNAL_PORT" ] || [ -z "$SIGNAL_URL" ] || [ -z "$FRONTEND_PORT" ]; then
  echo -e "${RED}Error: Missing required environment variables${NC}"
  echo -e "Ensure SIGNAL_PORT, SIGNAL_URL, and FRONTEND_PORT are set in .env"
  exit 1
fi

echo -e "${GREEN}Starting Android Cloud Gaming...${NC}"
echo -e "  Signal port:   $SIGNAL_PORT"
echo -e "  Frontend port: $FRONTEND_PORT"
echo -e "  Signal URL:    $SIGNAL_URL"
echo ""

# Kill any leftover processes from previous runs
echo -e "${YELLOW}Cleaning up any existing processes...${NC}"
# Kill processes on signal port
fuser -k ${SIGNAL_PORT}/tcp 2>/dev/null || true
# Kill processes on frontend port
fuser -k ${FRONTEND_PORT}/tcp 2>/dev/null || true
# Stop docker container if running
sudo docker stop redroid-worker 2>/dev/null || true
sudo docker rm redroid-worker 2>/dev/null || true
echo -e "${GREEN}Cleanup complete${NC}"
echo ""

# Generate frontend config.js from env vars
echo -e "${YELLOW}Generating frontend config...${NC}"
cat > "$SCRIPT_DIR/frontend/config.js" << EOF
// Auto-generated by start.sh - do not edit
window.CONFIG = {
  SIGNAL_URL: '${SIGNAL_URL}'
};
EOF

# Track PIDs for cleanup
SIGNAL_PID=""
POD_PID=""
FRONTEND_PID=""

# Kill all started services and exit
fail() {
  echo -e "${RED}$1${NC}"
  echo -e "${RED}Killing all services...${NC}"
  [ -n "$SIGNAL_PID" ] && kill $SIGNAL_PID 2>/dev/null
  [ -n "$POD_PID" ] && kill $POD_PID 2>/dev/null
  [ -n "$FRONTEND_PID" ] && kill $FRONTEND_PID 2>/dev/null
  exit 1
}

# Function to wait for a port to be ready
wait_for_port() {
  local port=$1
  local name=$2
  local max_attempts=30
  local attempt=0

  while [ $attempt -lt $max_attempts ]; do
    if nc -z localhost "$port" 2>/dev/null; then
      return 0
    fi
    attempt=$((attempt + 1))
    sleep 0.2
  done

  return 1
}

# Start signal server
echo -e "${YELLOW}[1/3] Starting signal server on port $SIGNAL_PORT...${NC}"
cd "$SCRIPT_DIR/signal"
(trap '' INT; exec env SIGNAL_PORT=$SIGNAL_PORT npm run start) &
SIGNAL_PID=$!

if ! wait_for_port "$SIGNAL_PORT" "signal server"; then
  fail "Signal server failed to start (timeout on port $SIGNAL_PORT)"
fi
echo -e "${GREEN}       Signal server ready${NC}"

# Start pod server
echo -e "${YELLOW}[2/3] Starting pod server...${NC}"
cd "$SCRIPT_DIR/node/pod"
(trap '' INT; exec env SIGNAL_URL="${SIGNAL_URL}?role=pod" npm run start) &
POD_PID=$!
# Pod doesn't listen on a port, give it a moment to connect
sleep 1
if ! kill -0 $POD_PID 2>/dev/null; then
  fail "Pod server failed to start"
fi
echo -e "${GREEN}       Pod server ready${NC}"

# Start frontend
echo -e "${YELLOW}[3/3] Starting frontend server on port $FRONTEND_PORT...${NC}"
cd "$SCRIPT_DIR/frontend"
(trap '' INT; exec python3 -m http.server $FRONTEND_PORT) &
FRONTEND_PID=$!

if ! wait_for_port "$FRONTEND_PORT" "frontend server"; then
  fail "Frontend server failed to start (timeout on port $FRONTEND_PORT)"
fi
echo -e "${GREEN}       Frontend server ready${NC}"

echo ""
echo -e "${GREEN}All services started!${NC}"
echo -e "  Signal server PID: $SIGNAL_PID"
echo -e "  Pod server PID:    $POD_PID"
echo -e "  Frontend PID:      $FRONTEND_PID"
echo ""
echo -e "${GREEN}Frontend available at: http://localhost:$FRONTEND_PORT${NC}"
echo ""
echo -e "Type 'exit' or 'quit' to stop all services..."
echo ""

# Kill a process tree using SIGTERM, wait, then SIGKILL if needed
kill_tree() {
    local pid=$1
    local name=$2

    if [ -z "$pid" ] || ! kill -0 "$pid" 2>/dev/null; then
        return 0  # Already dead
    fi

    # Send SIGTERM to process group (negative PID)
    kill -TERM -$pid 2>/dev/null || kill -TERM $pid 2>/dev/null

    # Wait up to 3 seconds for graceful shutdown
    local i=0
    while [ $i -lt 30 ] && kill -0 "$pid" 2>/dev/null; do
        sleep 0.1
        i=$((i + 1))
    done

    # Force kill if still alive
    if kill -0 "$pid" 2>/dev/null; then
        echo -e "${YELLOW}Force killing $name...${NC}"
        kill -KILL -$pid 2>/dev/null || kill -KILL $pid 2>/dev/null
    fi

    wait "$pid" 2>/dev/null
}

# Cleanup function
cleanup() {
    echo -e "\n${RED}Stopping all services...${NC}"

    # Send SIGTERM to each service and wait for graceful shutdown
    kill_tree $FRONTEND_PID "frontend"
    kill_tree $POD_PID "pod"
    kill_tree $SIGNAL_PID "signal"

    # Also ensure docker container is stopped (in case pod didn't clean up)
    docker stop redroid-worker 2>/dev/null || true

    echo -e "${GREEN}All services stopped.${NC}"
    exit 0
}

trap cleanup SIGINT SIGTERM

# Wait for user to type exit/quit
while true; do
    read -r cmd
    case "$cmd" in
        exit|quit|q|stop)
            cleanup
            ;;
        *)
            echo -e "Type 'exit' or 'quit' to stop all services"
            ;;
    esac
done
