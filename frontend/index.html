<!DOCTYPE html> <!-- balls-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Android Cloud Gaming</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #fff;
    }
    h1 {
      margin-bottom: 20px;
      color: #eee;
    }
    #status {
      margin-bottom: 10px;
      padding: 8px 16px;
      background: #16213e;
      border-radius: 4px;
      font-size: 14px;
    }
    #status.connected { background: #1b4332; }
    #status.error { background: #7f1d1d; }
    #container {
      position: relative;
      border: 2px solid #333;
      border-radius: 8px;
      overflow: hidden;
    }
    #canvas {
      display: block;
      background: #000;
      touch-action: none;
    }
    #connect-btn {
      margin-top: 20px;
      padding: 12px 32px;
      font-size: 16px;
      background: #4361ee;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #connect-btn:hover {
      background: #3a56d4;
    }
    #connect-btn:disabled {
      background: #555;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <h1>Android Cloud Gaming</h1>
  <div id="status">Disconnected</div>
  <div id="container">
    <canvas id="canvas" width="360" height="640"></canvas>
  </div>
  <button id="connect-btn">Connect</button>
  <button id="test-tap-btn" style="margin-top:10px;padding:12px 32px;font-size:16px;background:#e63946;color:white;border:none;border-radius:6px;cursor:pointer;">Test Tap (center)</button>

  <script src="config.js"></script>
  <script>
    const SIGNAL_URL = window.CONFIG?.SIGNAL_URL || 'ws://localhost:8080';
    const SCREEN_WIDTH = 360;
    const SCREEN_HEIGHT = 640;

    let ws = null;
    let pc = null;
    let videoChannel = null;
    let inputChannel = null;
    let decoder = null;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const connectBtn = document.getElementById('connect-btn');

    function setStatus(text, type = '') {
      statusEl.textContent = text;
      statusEl.className = type;
    }

    // H.264 NAL Parser and Decoder
    class H264Decoder {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.decoder = null;
        this.buffer = new Uint8Array(0);
        this.sps = null;
        this.pps = null;
        this.timestamp = 0;
        this.configured = false;
        this.videoWidth = 0;
        this.videoHeight = 0;
        this.metadataReceived = false;
      }

      // Append incoming data to buffer
      appendData(data) {
        const incoming = new Uint8Array(data);
        console.log('Received chunk:', incoming.length, 'bytes, first 8:', Array.from(incoming.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join(' '));

        // Skip metadata packet (device name, starts with ASCII text like "redroid")
        // Also skip any tiny initial handshake packets
        if (!this.metadataReceived) {
          // Tiny packets before metadata - skip
          if (incoming.length < 8) {
            console.log('Skipping tiny pre-metadata packet');
            return;
          }
          // Check if this looks like metadata (starts with printable ASCII, not 0x00 or 0x80/0x40)
          if (incoming[0] >= 0x20 && incoming[0] <= 0x7E) {
            console.log('Skipping metadata packet (device name)');
            this.metadataReceived = true;
            return;
          }
          this.metadataReceived = true;
        }

        // Each scrcpy raw_stream packet has 8-byte header:
        // - Bit 63 (0x80): CONFIG flag (SPS/PPS)
        // - Bit 62 (0x40): KEY_FRAME flag
        // - Bits 0-61: PTS in microseconds
        if (incoming.length < 8) {
          console.log('Packet too small, skipping');
          return;
        }

        const flags = incoming[0];
        const isConfig = (flags & 0x80) !== 0;
        const isKeyframe = (flags & 0x40) !== 0;

        // Extract PTS from bytes 0-7 (big-endian, masking out flag bits)
        const ptsBytes = incoming.slice(0, 8);
        ptsBytes[0] &= 0x3F; // Clear flag bits
        const pts = Number(new DataView(ptsBytes.buffer).getBigUint64(0, false));

        console.log('Packet header:', { isConfig, isKeyframe, pts: pts / 1000 + 'ms' });

        // Strip 8-byte header, keep only H.264 data
        const h264Data = incoming.slice(8);

        const newBuffer = new Uint8Array(this.buffer.length + h264Data.length);
        newBuffer.set(this.buffer, 0);
        newBuffer.set(h264Data, this.buffer.length);
        this.buffer = newBuffer;
        this.processBuffer();
      }

      // Find NAL units in buffer and process them
      processBuffer() {
        const nalUnits = [];
        let lastStart = -1;

        // Find all NAL start codes
        for (let i = 0; i < this.buffer.length - 4; i++) {
          // Check for 4-byte start code (00 00 00 01)
          if (this.buffer[i] === 0 && this.buffer[i+1] === 0 &&
              this.buffer[i+2] === 0 && this.buffer[i+3] === 1) {
            if (lastStart !== -1) {
              nalUnits.push(this.buffer.slice(lastStart, i));
            }
            lastStart = i;
            i += 3;
          }
          // Check for 3-byte start code (00 00 01)
          else if (this.buffer[i] === 0 && this.buffer[i+1] === 0 && this.buffer[i+2] === 1) {
            if (lastStart !== -1) {
              nalUnits.push(this.buffer.slice(lastStart, i));
            }
            lastStart = i;
            i += 2;
          }
        }

        // Keep incomplete data in buffer (from last start code to end)
        if (lastStart !== -1 && nalUnits.length > 0) {
          this.buffer = this.buffer.slice(lastStart);
        } else if (lastStart === -1) {
          // No start codes found, clear buffer if it's getting too large
          if (this.buffer.length > 1024 * 1024) {
            console.warn('Buffer overflow, clearing');
            this.buffer = new Uint8Array(0);
          }
        }

        // Process found NAL units
        if (nalUnits.length > 0) {
          console.log('Found', nalUnits.length, 'NAL units');
        }
        for (const nal of nalUnits) {
          this.processNAL(nal);
        }
      }

      // Process a single NAL unit
      processNAL(nal) {
        if (nal.length < 5) return;

        // Get NAL type (5 bits after start code)
        const startCodeLen = (nal[2] === 1) ? 3 : 4;
        const nalType = nal[startCodeLen] & 0x1F;

        switch (nalType) {
          case 7: // SPS
            this.sps = nal;
            console.log('Got SPS, length:', nal.length);
            try {
              const dims = this.parseDimensionsFromSPS(nal);
              this.videoWidth = dims.width;
              this.videoHeight = dims.height;
              console.log('Video dimensions:', dims.width, 'x', dims.height);
              // Send dimensions to server
              if (inputChannel && inputChannel.readyState === 'open') {
                inputChannel.send(JSON.stringify({ type: 'videoDimensions', width: dims.width, height: dims.height }));
              }
            } catch (e) {
              console.error('Failed to parse SPS dimensions:', e);
            }
            this.tryConfigureDecoder();
            break;
          case 8: // PPS
            this.pps = nal;
            console.log('Got PPS, length:', nal.length);
            this.tryConfigureDecoder();
            break;
          case 5: // IDR (keyframe)
            this.decodeFrame(nal, true);
            break;
          case 1: // Non-IDR (P-frame)
            this.decodeFrame(nal, false);
            break;
        }
      }

      // Parse SPS to get codec string
      parseCodecFromSPS(sps) {
        const startCodeLen = (sps[2] === 1) ? 3 : 4;
        const profileIdc = sps[startCodeLen + 1];
        const constraints = sps[startCodeLen + 2];
        const levelIdc = sps[startCodeLen + 3];

        const hex = (n) => n.toString(16).padStart(2, '0').toUpperCase();
        return `avc1.${hex(profileIdc)}${hex(constraints)}${hex(levelIdc)}`;
      }

      // Parse SPS to get video dimensions
      parseDimensionsFromSPS(sps) {
        const startCodeLen = (sps[2] === 1) ? 3 : 4;
        const rbsp = this.removeEmulationPrevention(sps.slice(startCodeLen + 1));

        let bitPos = 0;
        const readBits = (n) => {
          let val = 0;
          for (let i = 0; i < n; i++) {
            const byteIdx = Math.floor(bitPos / 8);
            const bitIdx = 7 - (bitPos % 8);
            val = (val << 1) | ((rbsp[byteIdx] >> bitIdx) & 1);
            bitPos++;
          }
          return val;
        };
        const readUE = () => {
          let zeros = 0;
          while (readBits(1) === 0) zeros++;
          if (zeros === 0) return 0;
          return (1 << zeros) - 1 + readBits(zeros);
        };

        const profileIdc = readBits(8);
        readBits(8); // constraints
        readBits(8); // level
        readUE(); // seq_parameter_set_id

        if ([100,110,122,244,44,83,86,118,128,138,139,134].includes(profileIdc)) {
          const chromaFormat = readUE();
          if (chromaFormat === 3) readBits(1);
          readUE(); readUE();
          readBits(1);
          if (readBits(1)) {
            for (let i = 0; i < (chromaFormat !== 3 ? 8 : 12); i++) {
              if (readBits(1)) {
                const size = i < 6 ? 16 : 64;
                let last = 8, next = 8;
                for (let j = 0; j < size; j++) {
                  if (next !== 0) next = (last + readUE()) & 255;
                  last = next === 0 ? last : next;
                }
              }
            }
          }
        }

        readUE(); // log2_max_frame_num
        const picOrderCntType = readUE();
        if (picOrderCntType === 0) readUE();
        else if (picOrderCntType === 1) {
          readBits(1); readUE(); readUE();
          const n = readUE();
          for (let i = 0; i < n; i++) readUE();
        }
        readUE(); // max_num_ref_frames
        readBits(1); // gaps_in_frame_num_allowed

        const picWidthInMbs = readUE() + 1;
        const picHeightInMapUnits = readUE() + 1;
        const frameMbsOnly = readBits(1);
        if (!frameMbsOnly) readBits(1);
        readBits(1); // direct_8x8_inference

        let cropLeft = 0, cropRight = 0, cropTop = 0, cropBottom = 0;
        if (readBits(1)) {
          cropLeft = readUE();
          cropRight = readUE();
          cropTop = readUE();
          cropBottom = readUE();
        }

        const width = picWidthInMbs * 16 - (cropLeft + cropRight) * 2;
        const height = (2 - frameMbsOnly) * picHeightInMapUnits * 16 - (cropTop + cropBottom) * 2;

        return { width, height };
      }

      removeEmulationPrevention(data) {
        const result = [];
        for (let i = 0; i < data.length; i++) {
          if (i + 2 < data.length && data[i] === 0 && data[i+1] === 0 && data[i+2] === 3) {
            result.push(0, 0);
            i += 2;
          } else {
            result.push(data[i]);
          }
        }
        return new Uint8Array(result);
      }

      // Configure decoder once we have SPS and PPS
      async tryConfigureDecoder() {
        if (!this.sps || !this.pps || this.configured) return;

        const codec = this.parseCodecFromSPS(this.sps);
        console.log('Configuring decoder with codec:', codec);

        // Get dimensions (use parsed or default)
        const width = this.videoWidth || 360;
        const height = this.videoHeight || 640;

        const config = {
          codec: codec,
          codedWidth: width,
          codedHeight: height,
          optimizeForLatency: true,
        };

        // Check if codec is supported first
        try {
          const support = await VideoDecoder.isConfigSupported(config);
          console.log('Codec support check:', support);
          if (!support.supported) {
            // Try fallback
            config.codec = 'avc1.42E01E';
            const fallbackSupport = await VideoDecoder.isConfigSupported(config);
            if (!fallbackSupport.supported) {
              console.error('No supported codec found');
              return;
            }
            console.log('Using fallback codec: avc1.42E01E');
          }
        } catch (e) {
          console.warn('isConfigSupported failed, trying anyway:', e);
        }

        this.decoder = new VideoDecoder({
          output: (frame) => {
            this.ctx.drawImage(frame, 0, 0, this.canvas.width, this.canvas.height);
            frame.close();
          },
          error: (e) => {
            console.error('Decoder error:', e.message);
            // Reset and try again on next keyframe
            this.configured = false;
            this.decoder = null;
          }
        });

        try {
          this.decoder.configure(config);
          this.configured = true;
          console.log('Decoder configured successfully with', config.codec, width + 'x' + height);
        } catch (e) {
          console.error('Failed to configure decoder:', e);
          this.decoder = null;
        }
      }

      // Decode a video frame
      decodeFrame(nal, isKeyframe) {
        if (!this.decoder || this.decoder.state !== 'configured') {
          console.log('Decoder not ready, state:', this.decoder?.state);
          return;
        }
        console.log('Decoding frame:', isKeyframe ? 'KEY' : 'delta', 'size:', nal.length);

        // For keyframes, prepend SPS and PPS
        let frameData = nal;
        if (isKeyframe && this.sps && this.pps) {
          const combined = new Uint8Array(this.sps.length + this.pps.length + nal.length);
          combined.set(this.sps, 0);
          combined.set(this.pps, this.sps.length);
          combined.set(nal, this.sps.length + this.pps.length);
          frameData = combined;
        }

        try {
          // Debug: log what we're feeding the decoder
          const nalType = frameData[4] & 0x1F;
          console.log('Feeding decoder:', {
            isKeyframe,
            size: frameData.length,
            nalType,
            firstBytes: Array.from(frameData.slice(0, 10)).map(b => b.toString(16).padStart(2, '0')).join(' '),
            hasSPS: !!this.sps,
            hasPPS: !!this.pps,
            decoderState: this.decoder.state,
            queueSize: this.decoder.decodeQueueSize
          });

          const chunk = new EncodedVideoChunk({
            type: isKeyframe ? 'key' : 'delta',
            timestamp: this.timestamp,
            data: frameData,
          });
          this.decoder.decode(chunk);
          this.timestamp += 33333; // ~30fps in microseconds
        } catch (e) {
          console.error('Sync decode error:', e.name, e.message);
        }
      }

      reset() {
        if (this.decoder) {
          this.decoder.close();
          this.decoder = null;
        }
        this.buffer = new Uint8Array(0);
        this.sps = null;
        this.pps = null;
        this.timestamp = 0;
        this.configured = false;
        this.videoWidth = 0;
        this.metadataReceived = false;
        this.videoHeight = 0;
      }
    }

    let h264Decoder = null;

    // WebRTC setup
    async function connect() {
      connectBtn.disabled = true;
      setStatus('Connecting...');

      ws = new WebSocket(SIGNAL_URL);

      ws.onopen = () => {
        setStatus('Connected to signal server');
        ws.send(JSON.stringify({ type: 'start' }));
      };

      ws.onmessage = async (event) => {
        const msg = JSON.parse(event.data);
        console.log('Signal:', msg.type);

        switch (msg.type) {
          case 'offer':
            await handleOffer(msg);
            break;
          case 'ice-candidate':
            if (pc && msg.candidate) {
              await pc.addIceCandidate(msg.candidate);
            }
            break;
          case 'error':
            setStatus(msg.message, 'error');
            connectBtn.disabled = false;
            break;
        }
      };

      ws.onerror = (e) => {
        console.error('WebSocket error:', e);
        setStatus('Connection error', 'error');
        connectBtn.disabled = false;
      };

      ws.onclose = () => {
        setStatus('Disconnected');
        connectBtn.disabled = false;
        cleanup();
      };
    }

    async function handleOffer(msg) {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      pc.ondatachannel = (event) => {
        const channel = event.channel;
        console.log('Data channel:', channel.label);

        if (channel.label === 'video') {
          videoChannel = channel;
          channel.binaryType = 'arraybuffer';

          channel.onopen = () => {
            setStatus('Streaming', 'connected');
            h264Decoder = new H264Decoder(canvas);
          };

          channel.onmessage = (e) => {
            if (h264Decoder) {
              h264Decoder.appendData(e.data);
            }
          };
        } else if (channel.label === 'input') {
          inputChannel = channel;
          channel.onopen = () => {
            console.log('Input channel ready');
          };
        }
      };

      pc.onicecandidate = (event) => {
        if (event.candidate && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'ice-candidate',
            candidate: event.candidate
          }));
        }
      };

      pc.onconnectionstatechange = () => {
        console.log('Connection state:', pc.connectionState);
        if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
          setStatus('Disconnected', 'error');
          cleanup();
        }
      };

      await pc.setRemoteDescription({ type: 'offer', sdp: msg.sdp });
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      ws.send(JSON.stringify({
        type: 'answer',
        sdp: answer.sdp
      }));
    }

    function cleanup() {
      if (h264Decoder) {
        h264Decoder.reset();
        h264Decoder = null;
      }
      if (pc) {
        pc.close();
        pc = null;
      }
      videoChannel = null;
      inputChannel = null;
    }

    // Input handling - scale coordinates to actual video dimensions
    function sendInput(msg) {
      if (inputChannel && inputChannel.readyState === 'open') {
        // Scale coordinates from canvas space to video space
        if (h264Decoder && h264Decoder.videoWidth && h264Decoder.videoHeight) {
          const scaleX = h264Decoder.videoWidth / SCREEN_WIDTH;
          const scaleY = h264Decoder.videoHeight / SCREEN_HEIGHT;
          msg.x = Math.floor(msg.x * scaleX);
          msg.y = Math.floor(msg.y * scaleY);
        }
        inputChannel.send(JSON.stringify(msg));
      }
    }

    // Touch/Mouse events
    let isPointerDown = false;

    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      isPointerDown = true;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (SCREEN_WIDTH / rect.width);
      const y = (e.clientY - rect.top) * (SCREEN_HEIGHT / rect.height);

      sendInput({
        type: 'drag',
        action: 'start',
        pointerId: e.pointerId,
        x: Math.floor(x),
        y: Math.floor(y)
      });
    });

    canvas.addEventListener('pointermove', (e) => {
      if (!isPointerDown) return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (SCREEN_WIDTH / rect.width);
      const y = (e.clientY - rect.top) * (SCREEN_HEIGHT / rect.height);

      sendInput({
        type: 'drag',
        action: 'move',
        pointerId: e.pointerId,
        x: Math.floor(x),
        y: Math.floor(y)
      });
    });

    canvas.addEventListener('pointerup', (e) => {
      e.preventDefault();
      isPointerDown = false;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (SCREEN_WIDTH / rect.width);
      const y = (e.clientY - rect.top) * (SCREEN_HEIGHT / rect.height);

      sendInput({
        type: 'drag',
        action: 'end',
        pointerId: e.pointerId,
        x: Math.floor(x),
        y: Math.floor(y)
      });
    });

    canvas.addEventListener('pointercancel', (e) => {
      isPointerDown = false;
      sendInput({
        type: 'drag',
        action: 'cancel',
        pointerId: e.pointerId,
        x: 0,
        y: 0
      });
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    connectBtn.addEventListener('click', connect);

    // Test tap button - sends a properly timed tap to center of screen
    document.getElementById('test-tap-btn').addEventListener('click', () => {
      if (inputChannel && inputChannel.readyState === 'open' && h264Decoder) {
        // Use actual video dimensions for center tap
        const videoW = h264Decoder.videoWidth || SCREEN_WIDTH;
        const videoH = h264Decoder.videoHeight || SCREEN_HEIGHT;
        const testX = Math.floor(videoW / 2);
        const testY = Math.floor(videoH / 2);
        console.log('Sending test tap to:', testX, testY, 'video:', videoW, 'x', videoH);
        inputChannel.send(JSON.stringify({ type: 'testTap', x: testX, y: testY }));
      } else {
        alert('Not connected');
      }
    });
  </script>
</body>
</html>
