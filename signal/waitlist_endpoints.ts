/**
 * Waitlist Endpoints Module
 * Handles joining the waitlist and generating invite codes for waitlist users
 */

import { verifyToken } from "./db/auth.js";
import { getSupabase } from "./db/supabase.js";

// ============================================================================
// Configuration
// ============================================================================

const WAITLIST_CONFIG = {
  REFERRER_REWARD_HOURS: 1,
  NEW_USER_BONUS_HOURS: 0,
};

// ============================================================================
// Types
// ============================================================================

export interface JoinWaitlistResult {
  status: number;
  body: {
    success: boolean;
    error?: string;
    referral_code?: string;
  };
}

export interface GenerateInvitesResult {
  status: number;
  body: {
    success: boolean;
    error?: string;
    message?: string;
    processed?: Array<{ user_id: string; email?: string; invite_code: string }>;
    errors?: Array<{ user_id: string; error: string }>;
  };
}

export interface AdminResult {
  status: number;
  body: {
    success: boolean;
    error?: string;
  };
}

// ============================================================================
// Join Waitlist
// ============================================================================

/**
 * Join the waitlist with an optional referral code
 *
 * This is done on the backend because:
 * - RLS prevents frontend from validating other users' referral codes
 * - Service key bypasses RLS for these operations
 *
 * @param token - The user's authentication token
 * @param referralCode - Optional referral code from another user
 * @returns JoinWaitlistResult with status code and response body
 */
export async function joinWaitlist(
  token: string,
  referralCode?: string
): Promise<JoinWaitlistResult> {
  try {
    // Verify the token and get user info
    const user = await verifyToken(token);

    if (!user) {
      return {
        status: 401,
        body: {
          success: false,
          error: "Invalid or expired token",
        },
      };
    }

    const supabase = getSupabase();
    if (!supabase) {
      return {
        status: 500,
        body: {
          success: false,
          error: "Database not configured",
        },
      };
    }

    // Validate referral code if provided
    let referrerId: string | null = null;
    if (referralCode && referralCode.trim() !== "") {
      const { data: referrerData, error: referrerError } = await supabase
        .from("waitlist")
        .select("user_id")
        .eq("referral_code", referralCode)
        .single();

      if (referrerError || !referrerData) {
        return {
          status: 400,
          body: {
            success: false,
            error: "Invalid referral code",
          },
        };
      }

      referrerId = referrerData.user_id;

      // Prevent self-referral
      if (referrerId === user.id) {
        return {
          status: 400,
          body: {
            success: false,
            error: "You cannot use your own referral code",
          },
        };
      }
    }

    // Calculate initial time_joined (with bonus if using referral)
    let timeJoined = new Date();
    if (referrerId && WAITLIST_CONFIG.NEW_USER_BONUS_HOURS > 0) {
      timeJoined = new Date(
        timeJoined.getTime() -
          WAITLIST_CONFIG.NEW_USER_BONUS_HOURS * 60 * 60 * 1000
      );
    }

    // Insert the new waitlist entry
    const { data: insertData, error: insertError } = await supabase
      .from("waitlist")
      .insert({
        user_id: user.id,
        // time_joined: timeJoined.toISOString(), // todo ri\ght here if wanted we can also reward user who has USED a ref code (if ref code is not null)
        // referral code generated by supabase
        referral_code_used_to_join: referralCode || null,
      })
      .select("referral_code")
      .single();

    const newReferralCode = insertData?.referral_code;

    if (insertError || !newReferralCode) {
      if (insertError?.code === "23505") {
        return {
          status: 400,
          body: {
            success: false,
            error: "You are already on the waitlist",
          },
        };
      }
      console.error("Join waitlist error:", insertError);
      return {
        status: 500,
        body: {
          success: false,
          error: insertError?.message || "Failed to generate referral code",
        },
      };
    }

    // Reward the referrer if a valid code was used
    if (referrerId) {
      // Get referrer's current time_joined
      const { data: referrerEntry, error: fetchError } = await supabase
        .from("waitlist")
        .select("time_joined")
        .eq("user_id", referrerId)
        .single();

      if (!fetchError && referrerEntry) {
        const currentTime = new Date(referrerEntry.time_joined);
        const newTime = new Date(
          currentTime.getTime() -
            WAITLIST_CONFIG.REFERRER_REWARD_HOURS * 60 * 60 * 1000
        );

        const { error: updateError } = await supabase
          .from("waitlist")
          .update({ time_joined: newTime.toISOString() })
          .eq("user_id", referrerId);

        if (updateError) {
          console.error("Failed to reward referrer:", updateError);
          // Don't fail the join, just log the error
        } else {
          console.log(
            `Rewarded referrer ${referrerId} with ${WAITLIST_CONFIG.REFERRER_REWARD_HOURS} hour(s) boost`
          );
        }
      }
    }

    console.log(
      `User ${user.id} joined waitlist with referral code ${newReferralCode}`
    );
    return {
      status: 200,
      body: {
        success: true,
        referral_code: newReferralCode,
      },
    };
  } catch (err) {
    console.error("Join waitlist error:", err);
    return {
      status: 500,
      body: {
        success: false,
        error: "Internal server error",
      },
    };
  }
}

/**
 * Take the first N users off the waitlist and generate invite codes for them
 *
 * TODO: Add admin authentication
 *
 * @param count - Number of users to process (capped at 100)
 * @returns CSV string with email,invite_code
 */
export async function generateInvites(count: number): Promise<string> {
  const processCount = Math.min(count, 100);

  const supabase = getSupabase();
  if (!supabase) {
    throw new Error("Database not configured");
  }

  // Get the first N users from waitlist, ordered by time_joined (earliest first)
  const { data: waitlistUsers, error: fetchError } = await supabase
    .from("waitlist")
    .select("user_id")
    .order("time_joined", { ascending: true })
    .limit(processCount);

  if (fetchError) {
    throw new Error(`Failed to fetch waitlist: ${fetchError.message}`);
  }

  if (!waitlistUsers || waitlistUsers.length === 0) {
    return "email,invite_code";
  }

  const rows: string[] = ["email,invite_code"];

  for (const waitlistUser of waitlistUsers) {
    const userId = waitlistUser.user_id;

    // Get user email
    const { data: userData } = await supabase.auth.admin.getUserById(userId);
    const email = userData?.user?.email;
    if (!email) {
      console.error(`No email found for user ${userId}`);
      continue;
    }

    // Insert into invite_codes table
    const { data: inviteData, error: insertError } = await supabase
      .from("invite_codes")
      .insert({})
      .select("invite_code")
      .single();

    if (insertError || !inviteData) {
      console.error(`Failed to create invite for ${userId}:`, insertError);
      continue;
    }

    const inviteCode = inviteData.invite_code;

    // Remove from waitlist
    const { error: deleteError } = await supabase
      .from("waitlist")
      .delete()
      .eq("user_id", userId);

    if (deleteError) {
      console.error(`Failed to remove ${userId} from waitlist:`, deleteError);
    }

    rows.push(`${email},${inviteCode}`);
    console.log(`Generated invite for ${email}: ${inviteCode}`);
  }

  return rows.join("\n");
}

// console.log(await generateInvites(21));
// todo need nodemailer as TS is ass
