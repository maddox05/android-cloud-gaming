<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Android Cloud Gaming</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            margin-bottom: 20px;
        }

        .container {
            max-width: 800px;
            width: 100%;
        }

        .connection-panel {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input {
            width: 100%;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #333;
            color: #fff;
            font-size: 14px;
            box-sizing: border-box;
        }

        button {
            width: 100%;
            padding: 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .video-container {
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 9 / 16;
            max-width: 360px;
            margin: 0 auto;
        }

        video {
            width: 100%;
            height: 100%;
            display: block;
        }

        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .status.connecting {
            background-color: #ff9800;
            color: #000;
        }

        .status.connected {
            background-color: #4CAF50;
        }

        .status.error {
            background-color: #f44336;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Android Cloud Gaming</h1>

        <div class="connection-panel">
            <div class="input-group">
                <label for="serverIp">Server IP Address:</label>
                <input type="text" id="serverIp" placeholder="e.g., 192.168.1.100:8080" value="localhost:8080">
            </div>

            <button id="connectBtn" onclick="connect()">Connect</button>

            <div id="status" class="status" style="display: none;"></div>
        </div>

        <div class="video-container">
            <video id="video" autoplay playsinline></video>
        </div>
    </div>

    <script>
        let peerConnection = null;
        let dataChannel = null;
        let serverAddress = '';
        let frameCount = 0;
        let lastFrameLogTime = Date.now();

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
            status.style.display = 'block';
        }

        function sendInputEvent(type, data) {
            if (!dataChannel) {
                console.error('âŒ Data channel not initialized! dataChannel is null');
                console.log('Connection state:', peerConnection?.connectionState);
                return;
            }

            if (dataChannel.readyState !== 'open') {
                console.error(`âŒ Data channel not ready! State: ${dataChannel.readyState}`);
                console.log('Data channel:', dataChannel);
                return;
            }

            const event = {
                type: type,
                timestamp: Date.now(),
                ...data
            };

            const jsonStr = JSON.stringify(event);
            try {
                dataChannel.send(jsonStr);
                console.log(`âœ“ [INPUT] Sent at ${event.timestamp} ms | Type: ${type}`, data);
            } catch (err) {
                console.error('âŒ Failed to send input event:', err);
            }
        }

        function setupInputHandlers() {
            const video = document.getElementById('video');

            console.log('ðŸŽ® Setting up input handlers');

            video.style.touchAction = 'none';
            video.style.cursor = 'pointer';

            let touchStartPos = null;
            let touchStartTime = null;
            let lastTouchTime = 0;

            // Mouse click handler (only fires on non-touch devices)
            video.addEventListener('click', (e) => {
                // Prevent duplicate if touch event just fired
                if (Date.now() - lastTouchTime < 500) {
                    console.log('ðŸš« Ignoring click (touch event just fired)');
                    return;
                }

                e.preventDefault();
                const rect = video.getBoundingClientRect();

                const relX = (e.clientX - rect.left) / rect.width;
                const relY = (e.clientY - rect.top) / rect.height;

                const deviceX = Math.round(relX * 1080);
                const deviceY = Math.round(relY * 1920);

                console.log(`ðŸ–±ï¸  Click -> tap (${deviceX}, ${deviceY})`);
                sendInputEvent('tap', { x: deviceX, y: deviceY });
            });

            // Touch start - record position for swipe detection
            video.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];

                touchStartPos = {
                    x: touch.clientX,
                    y: touch.clientY
                };
                touchStartTime = Date.now();
            });

            // Touch end - determine if tap or swipe
            video.addEventListener('touchend', (e) => {
                e.preventDefault();
                lastTouchTime = Date.now(); // Prevent click event from firing

                if (!touchStartPos) return;

                const touch = e.changedTouches[0];
                const rect = video.getBoundingClientRect();

                const endX = touch.clientX;
                const endY = touch.clientY;

                const deltaX = Math.abs(endX - touchStartPos.x);
                const deltaY = Math.abs(endY - touchStartPos.y);
                const deltaTime = Date.now() - touchStartTime;

                // If movement is small and quick, it's a tap
                if (deltaX < 10 && deltaY < 10 && deltaTime < 300) {
                    const relX = (touchStartPos.x - rect.left) / rect.width;
                    const relY = (touchStartPos.y - rect.top) / rect.height;

                    const deviceX = Math.round(relX * 1080);
                    const deviceY = Math.round(relY * 1920);

                    console.log(`ðŸ‘† Touch -> tap (${deviceX}, ${deviceY})`);
                    sendInputEvent('tap', { x: deviceX, y: deviceY });
                } else {
                    // It's a swipe
                    const startRelX = (touchStartPos.x - rect.left) / rect.width;
                    const startRelY = (touchStartPos.y - rect.top) / rect.height;
                    const endRelX = (endX - rect.left) / rect.width;
                    const endRelY = (endY - rect.top) / rect.height;

                    const deviceX1 = Math.round(startRelX * 1080);
                    const deviceY1 = Math.round(startRelY * 1920);
                    const deviceX2 = Math.round(endRelX * 1080);
                    const deviceY2 = Math.round(endRelY * 1920);

                    console.log(`ðŸ‘† Touch -> swipe (${deviceX1},${deviceY1}) to (${deviceX2},${deviceY2})`);
                    sendInputEvent('swipe', {
                        x: deviceX1,
                        y: deviceY1,
                        x2: deviceX2,
                        y2: deviceY2,
                        duration: Math.min(deltaTime, 1000)
                    });
                }

                touchStartPos = null;
            });

            // Keyboard handler for common Android keys
            document.addEventListener('keydown', (e) => {
                let keycode = null;

                switch(e.key) {
                    case 'Escape':
                        keycode = 'KEYCODE_BACK';
                        break;
                    case 'Home':
                        keycode = 'KEYCODE_HOME';
                        break;
                    case 'Enter':
                        keycode = 'KEYCODE_ENTER';
                        break;
                    case 'Backspace':
                        keycode = 'KEYCODE_DEL';
                        break;
                }

                if (keycode) {
                    e.preventDefault();
                    console.log(`âŒ¨ï¸  Key: ${e.key} -> ${keycode}`);
                    sendInputEvent('keyevent', { keycode: keycode });
                }
            });

            console.log('âœ“ Input handlers configured');
        }

        async function connect() {
            const serverIp = document.getElementById('serverIp').value.trim();
            if (!serverIp) {
                showStatus('Please enter a server IP address', 'error');
                return;
            }

            serverAddress = serverIp.startsWith('http') ? serverIp : 'http://' + serverIp;

            const connectBtn = document.getElementById('connectBtn');
            connectBtn.disabled = true;
            showStatus('Connecting...', 'connecting');

            try {
                // Create RTCPeerConnection with multiple STUN servers
                peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ],
                    iceCandidatePoolSize: 10
                });

                console.log('Created peer connection');

                // Add a transceiver to receive video (this ensures proper SDP generation)
                peerConnection.addTransceiver('video', {
                    direction: 'recvonly'
                });
                console.log('Added video transceiver');

                // Create data channel BEFORE creating offer (must be done on offering side)
                dataChannel = peerConnection.createDataChannel('input');
                console.log('ðŸŽ® Created data channel:', dataChannel.label);

                dataChannel.onopen = () => {
                    console.log('ðŸŽ‰ DATA CHANNEL OPENED!');
                    console.log('   State:', dataChannel.readyState);
                    setupInputHandlers();
                };

                dataChannel.onclose = () => {
                    console.log('ðŸ”’ Data channel closed');
                };

                dataChannel.onerror = (err) => {
                    console.error('âŒ Data channel error:', err);
                };

                dataChannel.onmessage = (msg) => {
                    console.log('ðŸ“¨ Message from server:', msg.data);
                };

                // Log ICE candidates as they're discovered
                let candidateCount = 0;
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        candidateCount++;
                        console.log(`ðŸ§Š Client ICE candidate #${candidateCount}:`, event.candidate.candidate);
                    } else {
                        console.log(`âœ“ Client ICE gathering complete (${candidateCount} candidates total)`);
                    }
                };

                // Monitor ICE gathering state
                peerConnection.onicegatheringstatechange = () => {
                    console.log('ðŸ” ICE Gathering State:', peerConnection.iceGatheringState);
                };

                // Monitor ICE connection state
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('ðŸ“¡ ICE Connection State:', peerConnection.iceConnectionState);
                    if (peerConnection.iceConnectionState === 'connected') {
                        console.log('ðŸŽ‰ ICE Connected!');
                        showStatus('Connected - Waiting for video...', 'connected');
                    } else if (peerConnection.iceConnectionState === 'failed') {
                        console.error('âŒ ICE Connection Failed');
                        showStatus('ICE connection failed', 'error');
                        connectBtn.disabled = false;
                    }
                };

                // Handle incoming video track
                peerConnection.ontrack = (event) => {
                    console.log('ðŸ“¹ Received video track!');
                    console.log('Track ID:', event.track.id);
                    console.log('Streams:', event.streams.length);
                    const video = document.getElementById('video');
                    if (event.streams && event.streams[0]) {
                        video.srcObject = event.streams[0];
                        showStatus('ðŸŽ¬ Streaming video!', 'connected');

                        // Log frame reception
                        video.addEventListener('loadeddata', () => {
                            console.log('ðŸ“¹ [FRAME] First frame loaded');
                        });

                        // Monitor frame rate using requestVideoFrameCallback if available
                        if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
                            const logFrames = () => {
                                frameCount++;
                                const now = Date.now();

                                // Log every 30 frames (approximately 1 second at 30fps)
                                if (frameCount % 30 === 0) {
                                    const elapsed = now - lastFrameLogTime;
                                    const fps = 30000 / elapsed; // frames per second
                                    console.log(`ðŸ“¹ [FRAME] Received frame #${frameCount} at ${now} ms | FPS: ${fps.toFixed(1)}`);
                                    lastFrameLogTime = now;
                                }

                                video.requestVideoFrameCallback(logFrames);
                            };
                            video.requestVideoFrameCallback(logFrames);
                        } else {
                            // Fallback for browsers without requestVideoFrameCallback
                            video.addEventListener('timeupdate', () => {
                                frameCount++;
                                if (frameCount % 30 === 0) {
                                    console.log(`ðŸ“¹ [FRAME] Playing frame #${frameCount} at ${Date.now()} ms`);
                                }
                            });
                        }
                    }
                };

                // Handle connection state changes
                peerConnection.onconnectionstatechange = () => {
                    console.log('ðŸ”Œ Connection State:', peerConnection.connectionState);
                    if (peerConnection.connectionState === 'failed') {
                        showStatus('Connection failed', 'error');
                        connectBtn.disabled = false;
                    } else if (peerConnection.connectionState === 'disconnected') {
                        showStatus('Connection lost', 'error');
                        connectBtn.disabled = false;
                    } else if (peerConnection.connectionState === 'connected') {
                        console.log('âœ“ Peer connection established');
                    }
                };

                // Create offer
                console.log('Creating offer...');
                const offer = await peerConnection.createOffer();

                console.log('Setting local description...');
                await peerConnection.setLocalDescription(offer);

                console.log('Initial SDP:', offer.sdp.substring(0, 500));

                // Wait for ICE gathering with timeout
                showStatus('Gathering connection info...', 'connecting');

                await new Promise((resolve) => {
                    const timeout = setTimeout(() => {
                        console.log('ICE gathering timeout after 3 seconds');
                        resolve();
                    }, 3000);

                    const checkComplete = () => {
                        if (peerConnection.iceGatheringState === 'complete') {
                            console.log('ICE gathering completed');
                            clearTimeout(timeout);
                            resolve();
                        }
                    };

                    if (peerConnection.iceGatheringState === 'complete') {
                        clearTimeout(timeout);
                        resolve();
                    } else {
                        peerConnection.addEventListener('icegatheringstatechange', checkComplete);
                    }
                });

                // Prepare the offer to send
                const offerToSend = {
                    type: peerConnection.localDescription.type,
                    sdp: peerConnection.localDescription.sdp
                };

                console.log('ðŸ“¤ Sending offer to server...');
                console.log('   Offer type:', offerToSend.type);
                console.log('   SDP length:', offerToSend.sdp.length);
                console.log('   ICE candidates in SDP:', (offerToSend.sdp.match(/a=candidate/g) || []).length);

                showStatus('Sending offer to server...', 'connecting');

                // Send offer to server
                const response = await fetch(serverAddress + '/offer', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(offerToSend)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('âŒ Server error:', errorText);
                    throw new Error('Server returned ' + response.status + ': ' + errorText);
                }

                // Get answer from server
                const answer = await response.json();
                console.log('ðŸ“¥ Received answer from server');
                console.log('   Answer type:', answer.type);
                console.log('   SDP length:', answer.sdp.length);
                console.log('   ICE candidates in answer:', (answer.sdp.match(/a=candidate/g) || []).length);

                showStatus('Setting remote description...', 'connecting');
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                console.log('âœ“ Remote description set, ICE negotiation starting...');

                showStatus('Establishing connection...', 'connecting');

            } catch (error) {
                console.error('Connection error:', error);
                showStatus('Connection failed: ' + error.message, 'error');
                connectBtn.disabled = false;

                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
            }
        }

        // Allow Enter key to connect
        document.getElementById('serverIp').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                connect();
            }
        });
    </script>
</body>
</html>
