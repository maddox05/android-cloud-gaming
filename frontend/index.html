<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Android Cloud Gaming</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #fff;
    }
    h1 {
      margin-bottom: 20px;
      color: #eee;
    }
    #status {
      margin-bottom: 10px;
      padding: 8px 16px;
      background: #16213e;
      border-radius: 4px;
      font-size: 14px;
    }
    #status.connected { background: #1b4332; }
    #status.error { background: #7f1d1d; }
    #container {
      position: relative;
      border: 2px solid #333;
      border-radius: 8px;
      overflow: hidden;
    }
    #canvas {
      display: block;
      background: #000;
      touch-action: none;
    }
    #connect-btn {
      margin-top: 20px;
      padding: 12px 32px;
      font-size: 16px;
      background: #4361ee;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #connect-btn:hover {
      background: #3a56d4;
    }
    #connect-btn:disabled {
      background: #555;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <h1>Android Cloud Gaming</h1>
  <div id="status">Disconnected</div>
  <div id="container">
    <canvas id="canvas" width="360" height="640"></canvas>
  </div>
  <button id="connect-btn">Connect</button>

  <script src="config.js"></script>
  <script>
    const SIGNAL_URL = window.CONFIG?.SIGNAL_URL || 'ws://localhost:8080';
    const SCREEN_WIDTH = 360;
    const SCREEN_HEIGHT = 640;

    let ws = null;
    let pc = null;
    let videoChannel = null;
    let inputChannel = null;
    let decoder = null;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const connectBtn = document.getElementById('connect-btn');

    function setStatus(text, type = '') {
      statusEl.textContent = text;
      statusEl.className = type;
    }

    // H.264 NAL Parser and Decoder
    class H264Decoder {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.decoder = null;
        this.buffer = new Uint8Array(0);
        this.sps = null;
        this.pps = null;
        this.timestamp = 0;
        this.configured = false;
      }

      // Append incoming data to buffer
      appendData(data) {
        const incoming = new Uint8Array(data);
        console.log('Received chunk:', incoming.length, 'bytes, first 8:', Array.from(incoming.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join(' '));
        const newBuffer = new Uint8Array(this.buffer.length + incoming.length);
        newBuffer.set(this.buffer, 0);
        newBuffer.set(incoming, this.buffer.length);
        this.buffer = newBuffer;
        this.processBuffer();
      }

      // Find NAL units in buffer and process them
      processBuffer() {
        const nalUnits = [];
        let lastStart = -1;

        // Find all NAL start codes
        for (let i = 0; i < this.buffer.length - 4; i++) {
          // Check for 4-byte start code (00 00 00 01)
          if (this.buffer[i] === 0 && this.buffer[i+1] === 0 &&
              this.buffer[i+2] === 0 && this.buffer[i+3] === 1) {
            if (lastStart !== -1) {
              nalUnits.push(this.buffer.slice(lastStart, i));
            }
            lastStart = i;
            i += 3;
          }
          // Check for 3-byte start code (00 00 01)
          else if (this.buffer[i] === 0 && this.buffer[i+1] === 0 && this.buffer[i+2] === 1) {
            if (lastStart !== -1) {
              nalUnits.push(this.buffer.slice(lastStart, i));
            }
            lastStart = i;
            i += 2;
          }
        }

        // Keep incomplete data in buffer (from last start code to end)
        if (lastStart !== -1 && nalUnits.length > 0) {
          this.buffer = this.buffer.slice(lastStart);
        } else if (lastStart === -1) {
          // No start codes found, clear buffer if it's getting too large
          if (this.buffer.length > 1024 * 1024) {
            console.warn('Buffer overflow, clearing');
            this.buffer = new Uint8Array(0);
          }
        }

        // Process found NAL units
        if (nalUnits.length > 0) {
          console.log('Found', nalUnits.length, 'NAL units');
        }
        for (const nal of nalUnits) {
          this.processNAL(nal);
        }
      }

      // Process a single NAL unit
      processNAL(nal) {
        if (nal.length < 5) return;

        // Get NAL type (5 bits after start code)
        const startCodeLen = (nal[2] === 1) ? 3 : 4;
        const nalType = nal[startCodeLen] & 0x1F;

        switch (nalType) {
          case 7: // SPS
            this.sps = nal;
            console.log('Got SPS, length:', nal.length);
            this.tryConfigureDecoder();
            break;
          case 8: // PPS
            this.pps = nal;
            console.log('Got PPS, length:', nal.length);
            this.tryConfigureDecoder();
            break;
          case 5: // IDR (keyframe)
            this.decodeFrame(nal, true);
            break;
          case 1: // Non-IDR (P-frame)
            this.decodeFrame(nal, false);
            break;
        }
      }

      // Parse SPS to get codec string
      parseCodecFromSPS(sps) {
        const startCodeLen = (sps[2] === 1) ? 3 : 4;
        const profileIdc = sps[startCodeLen + 1];
        const constraints = sps[startCodeLen + 2];
        const levelIdc = sps[startCodeLen + 3];

        const hex = (n) => n.toString(16).padStart(2, '0').toUpperCase();
        return `avc1.${hex(profileIdc)}${hex(constraints)}${hex(levelIdc)}`;
      }

      // Configure decoder once we have SPS and PPS
      tryConfigureDecoder() {
        if (!this.sps || !this.pps || this.configured) return;

        const codec = this.parseCodecFromSPS(this.sps);
        console.log('Configuring decoder with codec:', codec);

        this.decoder = new VideoDecoder({
          output: (frame) => {
            this.ctx.drawImage(frame, 0, 0, this.canvas.width, this.canvas.height);
            frame.close();
          },
          error: (e) => {
            console.error('Decoder error:', e);
          }
        });

        try {
          this.decoder.configure({
            codec: codec,
            optimizeForLatency: true,
          });
          this.configured = true;
          console.log('Decoder configured successfully');
        } catch (e) {
          console.error('Failed to configure decoder:', e);
          // Try fallback codec
          try {
            this.decoder.configure({
              codec: 'avc1.42E01E', // Baseline Profile Level 3.0
              optimizeForLatency: true,
            });
            this.configured = true;
            console.log('Decoder configured with fallback codec');
          } catch (e2) {
            console.error('Fallback codec also failed:', e2);
          }
        }
      }

      // Decode a video frame
      decodeFrame(nal, isKeyframe) {
        if (!this.decoder || this.decoder.state !== 'configured') {
          console.log('Decoder not ready, state:', this.decoder?.state);
          return;
        }
        console.log('Decoding frame:', isKeyframe ? 'KEY' : 'delta', 'size:', nal.length);

        // For keyframes, prepend SPS and PPS
        let frameData = nal;
        if (isKeyframe && this.sps && this.pps) {
          const combined = new Uint8Array(this.sps.length + this.pps.length + nal.length);
          combined.set(this.sps, 0);
          combined.set(this.pps, this.sps.length);
          combined.set(nal, this.sps.length + this.pps.length);
          frameData = combined;
        }

        try {
          const chunk = new EncodedVideoChunk({
            type: isKeyframe ? 'key' : 'delta',
            timestamp: this.timestamp,
            data: frameData,
          });
          this.decoder.decode(chunk);
          this.timestamp += 33333; // ~30fps in microseconds
        } catch (e) {
          // Skip invalid chunks silently
        }
      }

      reset() {
        if (this.decoder) {
          this.decoder.close();
          this.decoder = null;
        }
        this.buffer = new Uint8Array(0);
        this.sps = null;
        this.pps = null;
        this.timestamp = 0;
        this.configured = false;
      }
    }

    let h264Decoder = null;

    // WebRTC setup
    async function connect() {
      connectBtn.disabled = true;
      setStatus('Connecting...');

      ws = new WebSocket(SIGNAL_URL);

      ws.onopen = () => {
        setStatus('Connected to signal server');
        ws.send(JSON.stringify({ type: 'start' }));
      };

      ws.onmessage = async (event) => {
        const msg = JSON.parse(event.data);
        console.log('Signal:', msg.type);

        switch (msg.type) {
          case 'offer':
            await handleOffer(msg);
            break;
          case 'ice-candidate':
            if (pc && msg.candidate) {
              await pc.addIceCandidate(msg.candidate);
            }
            break;
          case 'error':
            setStatus(msg.message, 'error');
            connectBtn.disabled = false;
            break;
        }
      };

      ws.onerror = (e) => {
        console.error('WebSocket error:', e);
        setStatus('Connection error', 'error');
        connectBtn.disabled = false;
      };

      ws.onclose = () => {
        setStatus('Disconnected');
        connectBtn.disabled = false;
        cleanup();
      };
    }

    async function handleOffer(msg) {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      pc.ondatachannel = (event) => {
        const channel = event.channel;
        console.log('Data channel:', channel.label);

        if (channel.label === 'video') {
          videoChannel = channel;
          channel.binaryType = 'arraybuffer';

          channel.onopen = () => {
            setStatus('Streaming', 'connected');
            h264Decoder = new H264Decoder(canvas);
          };

          channel.onmessage = (e) => {
            if (h264Decoder) {
              h264Decoder.appendData(e.data);
            }
          };
        } else if (channel.label === 'input') {
          inputChannel = channel;
          channel.onopen = () => {
            console.log('Input channel ready');
          };
        }
      };

      pc.onicecandidate = (event) => {
        if (event.candidate && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'ice-candidate',
            candidate: event.candidate
          }));
        }
      };

      pc.onconnectionstatechange = () => {
        console.log('Connection state:', pc.connectionState);
        if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
          setStatus('Disconnected', 'error');
          cleanup();
        }
      };

      await pc.setRemoteDescription({ type: 'offer', sdp: msg.sdp });
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      ws.send(JSON.stringify({
        type: 'answer',
        sdp: answer.sdp
      }));
    }

    function cleanup() {
      if (h264Decoder) {
        h264Decoder.reset();
        h264Decoder = null;
      }
      if (pc) {
        pc.close();
        pc = null;
      }
      videoChannel = null;
      inputChannel = null;
    }

    // Input handling
    function sendInput(msg) {
      if (inputChannel && inputChannel.readyState === 'open') {
        inputChannel.send(JSON.stringify(msg));
      }
    }

    // Touch/Mouse events
    let isPointerDown = false;

    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      isPointerDown = true;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (SCREEN_WIDTH / rect.width);
      const y = (e.clientY - rect.top) * (SCREEN_HEIGHT / rect.height);

      sendInput({
        type: 'drag',
        action: 'start',
        pointerId: e.pointerId,
        x: Math.floor(x),
        y: Math.floor(y)
      });
    });

    canvas.addEventListener('pointermove', (e) => {
      if (!isPointerDown) return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (SCREEN_WIDTH / rect.width);
      const y = (e.clientY - rect.top) * (SCREEN_HEIGHT / rect.height);

      sendInput({
        type: 'drag',
        action: 'move',
        pointerId: e.pointerId,
        x: Math.floor(x),
        y: Math.floor(y)
      });
    });

    canvas.addEventListener('pointerup', (e) => {
      e.preventDefault();
      isPointerDown = false;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (SCREEN_WIDTH / rect.width);
      const y = (e.clientY - rect.top) * (SCREEN_HEIGHT / rect.height);

      sendInput({
        type: 'drag',
        action: 'end',
        pointerId: e.pointerId,
        x: Math.floor(x),
        y: Math.floor(y)
      });
    });

    canvas.addEventListener('pointercancel', (e) => {
      isPointerDown = false;
      sendInput({
        type: 'drag',
        action: 'cancel',
        pointerId: e.pointerId,
        x: 0,
        y: 0
      });
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    connectBtn.addEventListener('click', connect);
  </script>
</body>
</html>
