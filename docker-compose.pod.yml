# multiple of these will run at the same time, so it needs to ensure that it can be run like this
services:
  redroid:
    image: ${REDROID_IMAGE}:${REDROID_TAG}
    privileged: true
    stop_grace_period: 0s
    cpus: 3
    mem_limit: 4g
    mem_reservation: 3g
    volumes:
      - redroid-base:/data-base # Shared base data partition
    tmpfs:
      - /data-diff:size=1G,mode=1777 # RAM-backed, auto-deleted on stop
    command:
      - androidboot.use_redroid_overlayfs=1
      - androidboot.redroid_width=${REDROID_WIDTH}
      - androidboot.redroid_height=${REDROID_HEIGHT}
      - androidboot.redroid_dpi=${REDROID_DPI}
      - androidboot.redroid_fps=${REDROID_FPS}
      - ro.secure=0 # maybe remove this??
    networks:
      - internal # Gives container an IP that host-networked worker can reach

  worker:
    network_mode: host
    build:
      context: .
      dockerfile: worker/Dockerfile
    restart: always # worker exits with proccess.exit(), that means docker restarts it, which clears state. this allows for fresh state after crash or for a new user
    stop_grace_period: 0s
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      SIGNAL_URL: ${SIGNAL_URL}
      # REDROID_HOST resolved dynamically via docker inspect using POD_NAME
      REDROID_WIDTH: ${REDROID_WIDTH}
      REDROID_HEIGHT: ${REDROID_HEIGHT}
      POD_NAME: ${COMPOSE_PROJECT_NAME}
      REDROID_VIDEO_BIT_RATE: ${REDROID_VIDEO_BIT_RATE}
    depends_on:
      - redroid

volumes:
  redroid-base:
    external: true
    name: redroid-base # Shared base data partition (create once, use by all pods)

networks:
  internal: # Per-pod network, gives redroid an IP the host-networked worker can reach
